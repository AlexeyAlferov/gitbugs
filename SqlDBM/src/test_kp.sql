-- ***************************** SqlDBM: Snowflake ****************************
-- * Generated by SqlDBM: MART SCHEMA, v18 by lesya.rylova+standard@gmail.com *


-- ************************************** test_kp
CREATE VIEW test_kp as
WITH temp_time_increment AS (
    -- a version of the CO_EVENTS_TIME_INCREMENT view, but not dependent on UI_PARMS
    SELECT
      co.HAULING_SITE
      , co.sublob
      , co.ro_key
      , co.event_type
      , co.event_start
      , co.event_end
    -- Here we are looking for the best version of the previous event's end time and the next
    -- event's start time
      , MIN(co.event_end) OVER (PARTITION BY co.HAULING_SITE, co.ro_key ORDER BY event_start ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) AS previous_end
      , MAX(co.event_start) OVER (PARTITION BY co.HAULING_SITE, co.ro_key ORDER BY event_start ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING) AS next_start
      , TIMESTAMPDIFF(second, previous_end, event_start)/3600 AS travel_time_to_hrs
      , TIMESTAMPDIFF(second, event_end, next_start)/3600 AS travel_time_from_hrs
      , TIMESTAMPDIFF(second, event_start, event_end)/3600 AS event_hrs
    FROM co_events co
    INNER JOIN good_routes_for_timing rec
        ON co.HAULING_SITE=rec.HAULING_SITE
        AND co.ro_key=rec.ro_key
        AND co.service_dt=rec.service_dt
),
good_route_stem_disp_return AS (
    -- For good routes, we can calculate disposal return times simply
	SELECT 
		HAULING_SITE
		, sublob
		, ro_key
		, SUM(COALESCE(travel_time_to_hrs, 0) + COALESCE(travel_time_from_hrs,0) + COALESCE(event_hrs,0)) AS stem_disp_return
		, TIMESTAMPDIFF(seconds, MIN(event_start), MAX(event_end))/3600 AS route_time
		, CASE WHEN route_time = 0 THEN 0 ELSE stem_disp_return/route_time END AS pct_stem
	FROM temp_time_increment
	WHERE UPPER(event_type) IN ('LANDFILL','LEAVE YARD', 'ARRIVE YARD')
	GROUP BY HAULING_SITE, sublob, ro_key
)
SELECT
	sublob
	, COUNT(ro_key) AS record_count
	, SUM(stem_disp_return) AS stem_disp_return
	, SUM(route_time) AS route_time
	, case when SUBLOB = 'ROOT' then 0.5 ELSE AVG(pct_stem) END AS avg_pct_stem 
FROM good_route_stem_disp_return
GROUP BY sublob;
